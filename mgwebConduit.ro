IRIS for Windows^MAC^mgweb-conduit routines^~Format=IRIS.S~^RAW
%RO on 17 Nov 2020   9:00 AM
conduitAPIs^MAC^^65700,32329.998334^0
conduitAPIs ; Conduit API handler functions
 ;
 ;----------------------------------------------------------------------------
 ;| mgweb-conduit: mg-web Implementation of the Conduit Back-end             |
 ;|                                                                          |
 ;| Copyright (c) 2020 M/Gateway Developments Ltd,                           |
 ;| Redhill, Surrey UK.                                                      |
 ;| All rights reserved.                                                     |
 ;|                                                                          |
 ;| http://www.mgateway.com                                                  |
 ;| Email: rtweed@mgateway.com                                               |
 ;|                                                                          |
 ;|                                                                          |
 ;| Licensed under the Apache License, Version 2.0 (the "License");          |
 ;| you may not use this file except in compliance with the License.         |
 ;| You may obtain a copy of the License at                                  |
 ;|                                                                          |
 ;|     http://www.apache.org/licenses/LICENSE-2.0                           |
 ;|                                                                          |
 ;| Unless required by applicable law or agreed to in writing, software      |
 ;| distributed under the License is distributed on an "AS IS" BASIS,        |
 ;| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
 ;| See the License for the specific language governing permissions and      |
 ;|  limitations under the License.                                          |
 ;----------------------------------------------------------------------------
 ;
 ; 22 November 2020
 ;
 QUIT
 ;
addError(type,text,errors) ;
  n id
  s id=$increment(errors("errors",type))
  s errors("errors",type,id)=text
  QUIT 1
  ;
bodyAndFields(req,category,requiredFields,optionalFields,errors) ;
  ;
  n field,noFields
  ;
  k errors
  ;
  i '$d(req("body"))!('$d(req("body",category))) d  QUIT
  . i $$addError("body","can't be empty",.errors)
  i $d(requiredFields) d
  . s field=""
  . f  s field=$o(requiredFields(field)) q:field=""  d
  . . i '$d(req("body",category,field)) d  q
  . . . i $$addError(field,"must be defined",.errors)
  . . i req("body",category,field)="" d  q
  . . . i $$addError(field,"can't be empty",.errors)
  i $d(optionalFields),optionalFields'="" d
  . s field=""
  . s noFields=1
  . f  s field=$o(optionalFields(field)) q:field=""  d
  . . i $d(req("body",category,field)) d  q
  . . . s noFields=0
  . . . i req("body",category,field)="" d  q
  . . . . i $$addError(field,"can't be blank",.errors)
  . i noFields d
  . . i $$addError(field,"doesn't contain any of the expected fields",.errors)
  QUIT $d(errors)
  ;
errorResponse(errors,statusCode) ;
  ;
  n crlf,header,json
  ;
  m ^errors($h)=errors
  i '$d(statusCode) s statusCode=422
  s json=$$arrayToJSON^%zmgwebUtils("errors")
  s crlf=$c(13,10)
  s header="HTTP/1.1 "_statusCode_" Not Found"_crlf
  s header=header_"Content-type: application/json"_crlf_crlf
  QUIT header_json
  ;
authenticate(req,res) ;
  ;
  n claims,failReason,id,jwtToken,payload,secret,valid
  ;
  m ^auth("req")=req
  i '$d(req("headers","authorization")) d  QUIT 0
  . s res("error")="Missing authorization"
  ;
  s jwtToken=$p(req("headers","authorization"),"Token ",2)
  i jwtToken="" d  QUIT 0
  . s res("error")="Missing JWT"
  ;
  s ^auth("jwt")=jwtToken
  s secret=$$getJWTSecret^%zmgwebJWT()
  s ^auth("secret")=secret
  s valid=$$authenticateJWT^%zmgwebJWT(jwtToken,secret,.failReason)
  i 'valid d  QUIT 0
  . s res("error")="Invalid JWT: "_failReason
  ;
  s payload=$$decodeJWT^%zmgwebJWT(jwtToken)
  i payload="" d  QUIT 0
  . s res("error")="Missing JWT Payload"
  i $$parseJSON^%zmgwebUtils(payload,.claims)
  i $g(claims("iss"))'=$$getIssuer^%zmgwebJWT() d  QUIT 0
  . s res("error")="Invalid JWT Issuer"
  i $g(claims("email"))="" d  QUIT 0
  . s res("error")="No email in JWT"
  s id=$$idByEmail^conduitUsers(claims("email"))
  i id="" d  QUIT 0
  . s res("error")="Unrecognised email in JWT"
  ;
  s claims("id")=id
  m res=claims
  ;
  QUIT 1
  ;
checkAuthorization(req,errors) ;
 ;
 n byUserId,claims
 ;
 k errors
 s byUserId=""
 i $d(req("headers","authorization")) d
 . i '$$authenticate(.req,.claims) d 
 . . s errors("errors","JWT",1)=claims("error")
 . e  d
 . . s byUserId=claims("id")
 QUIT byUserId
 ;
mustAuthenticate(req,errors)
 ;
 n claims,id
 ;
 k errors
 s id=""
 i '$$authenticate(.req,.claims) d
 . s errors("errors","JWT",1)=claims("error")
 e  d
 . s id=claims("id")
 QUIT id
 ;
getUserData(id,results) ;
 ;
 n json,payload,user
 ;
 k results
 ;
 i $$get^conduitUsers(id,.user)
 k user("password")
 k user("follows")
 s payload("email")=user("email")
 s user("token")=$$createJWT^%zmgwebJWT(.payload,5184000)
 m results("user")=user
 QUIT 1
  ;

trace(text) ;
 n id
 i '$d(text) s text=$h
 s id=$increment(^trace)
 s ^trace(id)=text
 QUIT
 ;
  ; ===========================
  ;
ping(req) ;
 n res
 s res("pong")="true"
 QUIT $$response^%zmgwebUtils(.res)
 ;
getTags(req) ;
 ;
 n json,tags
 ;
 ; no authorization needed
 ;
 i $$getTags^conduitArticles(.tags)
 i '$d(tags) d
 . s json="{""tags"":[]}"
 e  d
 . n results
 . m results("tags")=tags
 . s json=$$arrayToJSON^%zmgwebUtils("results")
 QUIT $$header^%zmgweb()_json
 ;
getArticlesList(req) ;
 ;
 n articles,author,byUserId,errors,favorited,json,max,offset,tag
 ;
 s offset=+$g(req("query","offset"))
 s max=+$g(req("query","max"))
 i 'max s max=10
 ;
 s byUserId=$$checkAuthorization(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s author=$g(req("query","author"))
 s tag=$g(req("query","tag"))
 s favorited=$g(req("query","favorited"))
 ;
 i author'="" d
 . i $$byAuthor^conduitArticles(author,byUserId,offset,max,.articles)
 e  i tag'="" d
 . i $$byTag^conduitArticles(tag,byUserId,offset,max,.articles)
 e  i favorited'="" d
 . i $$favoritedBy^conduitArticles(favorited,byUserId,offset,max,.articles)
 e  d
 . i $$latest^conduitArticles(byUserId,offset,max,.articles)
 ;
 i '$d(articles("articles")) d
 . s json="{""articles"":[],""articlesCount"": 0}"
 e  d
 . s json=$$arrayToJSON^%zmgwebUtils("articles")
 QUIT $$header^%zmgweb()_json
 ;
registerUser(req) ;
 ;
 n email,errors,id,password,payload,requiredFields,results
 n secret,user,username
 ;
 s requiredFields("username")=""
 s requiredFields("email")=""
 s requiredFields("password")=""
 i $$bodyAndFields(.req,"user",.requiredFields,"",.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s username=req("body","user","username")
 i username'?1A.AN!($l(username)>50) d
 . i $$addError("username","is invalid",.errors)
 i $$usernameExists^conduitUsers(username) d
 . i $$addError("username","has already been taken",.errors)
 ;
 s email=req("body","user","email")
 i $l(email)>255 d
 . i $$addError("email","is invalid",.errors)
 e  d
 . i '$$isValidEmail^%zmgwebUtils(email) d
 . . i $$addError("email","is invalid",.errors)
 . e  d
 . . i $$emailExists^conduitUsers(email) d
 . . . i $$addError("email","has already been taken",.errors)
 ;
 s password=req("body","user","password")
 i $l(password)<6 d
 . i $$addError("password","must be 6 or more characters in length",.errors)
 ;
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 ; Create the persistent User record
 ;
 m user=req("body","user")
 s id=$$create^conduitUsers(.user)
 ;
 ; now retrieve the user object with JWT
 ;
 i $$getUserData(id,.results)
 QUIT $$response^%zmgwebUtils(.results)
 ;
getArticlesFeed(req) ;
 ;
 n articles,errors,id,json,max,offset
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s offset=+$g(req("query","offset"))
 s max=+$g(req("query","limit"))
 i 'max s max=20
 ;
 i $$getFeed^conduitArticles(id,offset,max,.articles)
 i '$d(articles("articles")) d
 . s json="{""articles"":[],""articlesCount"": 0}"
 e  d
 . s json=$$arrayToJSON^%zmgwebUtils("articles")
 QUIT $$header^%zmgweb()_json
 ;
getUser(req) ;
 ;
 n errors,id,results
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 i $$getUserData(id,.results)
 QUIT $$response^%zmgwebUtils(.results)
 ;
getProfile(req) ;
 ;
 n byUserId,errors,ofUserId,profile,results,username
 ;
 s byUserId=$$checkAuthorization(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 i $g(req("params","username"))="" d  QUIT $$errorResponse(.errors)
 . i $$addError("username","must be specified",.errors)
 s username=req("params","username")
 i '$$usernameExists^conduitUsers(username) QUIT $$notFound^%zmgweb()
 ;
 s ofUserId=$$idByUsername^conduitUsers(username)
 i $$getProfile^conduitUsers(ofUserId,byUserId,.profile)
 m results("profile")=profile
 QUIT $$response^%zmgwebUtils(.results)
 ;
authenticateUser(req) ;
 ;
 n email,errors,id,ok,password,requiredFields
 ;
 ; check for body with non-empty email and password
 ;
 s requiredFields("email")=""
 s requiredFields("password")=""
 i $$bodyAndFields(.req,"user",.requiredFields,"",.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s email=req("body","user","email")
 s password=req("body","user","password")
 s ok=$$authenticate^conduitUsers(email,password)
 i 'ok d  QUIT $$errorResponse(.errors)
 . i $$addError("email or password","is invalid",.errors)
 ;
 ; now retrieve the user object with JWT
 ;
 s id=$$idByEmail^conduitUsers(email)
 i $$getUserData(id,.results)
 QUIT $$response^%zmgwebUtils(.results)
 ;
createArticle(req) ;
 ;
 n article,data,description,errors,id,requiredFields
 n results,title
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s requiredFields("title")=""
 s requiredFields("description")=""
 s requiredFields("body")=""
 i $$bodyAndFields(.req,"article",.requiredFields,"",.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s title=req("body","article","title")
 i $l(title)>255 d
 . i $$addError("title","must be no longer than 255 characters",.errors)
 ;
 s description=req("body","article","description")
 i $l(description)>255 d
 . i $$addError("description","must be no longer than 255 characters",.errors)
 ;
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 m data=req("body","article")
 s articleId=$$create^conduitArticles(id,.data)
 ;
 ; now retrieve the article object
 ;
 i $$get^conduitArticles(articleId,id,.article)
 m results("article")=article
 QUIT $$response^%zmgwebUtils(.results)
 ;
getArticleBySlug(req) ;
 ;
 n article,articleId,byUserId,errors,results,slug
 ;
 s byUserId=$$checkAuthorization(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s slug=$g(req("params","slug"))
 i slug="" d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," slug not defined",.errors)
 ;
 s articleId=$$getIdBySlug^conduitArticles(slug)
 i articleId="" QUIT $$notFound^%zmgweb()
 ;
 i $$get^conduitArticles(articleId,byUserId,.article)
 m results("article")=article
 QUIT $$response^%zmgwebUtils(.results)
 ;
getComments(req) ;
 ;
 n articleId,byUserId,comments,errors,json,slug
 ;
 s byUserId=$$checkAuthorization(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s slug=$g(req("params","slug"))
 i slug="" d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," slug not defined",.errors)
 ;
 s articleId=$$getIdBySlug^conduitArticles(slug)
 i articleId="" QUIT $$notFound^%zmgweb()
 ;
 i $$byUser^conduitComments(byUserId,articleId,.comments)
 i '$d(comments) d
 . s json="{""comments"":[]}"
 e  d
 . n results
 . m results("comments")=comments
 . s json=$$arrayToJSON^%zmgwebUtils("results")
 QUIT $$header^%zmgweb()_json
 ;
addComment(req) ;
 ;
 n articleId,body,comment,commentId,errors,id
 n requiredFields,results,slug
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s requiredFields("body")=""
 i $$bodyAndFields(.req,"comment",.requiredFields,"",.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s slug=$g(req("params","slug"))
 i slug="" d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," slug not defined",.errors)
 ;
 s articleId=$$getIdBySlug^conduitArticles(slug)
 i articleId="" QUIT $$notFound^%zmgweb()
 ;
 s body=req("body","comment","body")
 s commentId=$$create^conduitComments(id,articleId,body)
 i $$get^conduitComments(commentId,id,.comment)
 ;
 m results("comment")=comment
 QUIT $$response^%zmgwebUtils(.results)
 ;
deleteComment(req) ;
 ;
 n articleId,commentId,errors,id,json,slug
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s slug=$g(req("params","slug"))
 i slug="" d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," slug not defined",.errors)
 ;
 s articleId=$$getIdBySlug^conduitArticles(slug)
 i articleId="" QUIT $$notFound^%zmgweb()
 ;
 s commentId=$g(req("params","id"))
 i commentId="" d  QUIT $$errorResponse(.errors)
 . i $$addError("comment"," Id not defined",.errors)
 ;
 i '$$exists^conduitComments(commentId) QUIT $$notFound^%zmgweb()
 ;
 i $$getAuthor^conduitComments(commentId)'=id d  QUIT $$errorResponse(.errors)
 . i $$addError("comment","not owned by author",.errors)
 ;
 i $$del^conduitComments(commentId)
 s json="{}"
 QUIT $$header^%zmgweb()_json
 ;
updateArticle(req) ;
 ;
 n article,articleId,data,description,errors,id,requiredFields
 n results,slug,title
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s requiredFields("title")=""
 s requiredFields("description")=""
 s requiredFields("body")=""
 i $$bodyAndFields(.req,"article",.requiredFields,"",.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s title=req("body","article","title")
 i $l(title)>255 d
 . i $$addError("title","must be no longer than 255 characters",.errors)
 ;
 s description=req("body","article","description")
 i $l(description)>255 d
 . i $$addError("description","must be no longer than 255 characters",.errors)
 ;
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s slug=$g(req("params","slug"))
 i slug="" d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," slug not defined",.errors)
 ;
 s articleId=$$getIdBySlug^conduitArticles(slug)
 i articleId="" QUIT $$notFound^%zmgweb()
 ;
 i $$getAuthor^conduitArticles(articleId)'=id d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," not owned by author",.errors)
 ;
 m data=req("body","article")
 i $$update^conduitArticles(articleId,id,.data)
 ;
 ; now retrieve the article object
 ;
 i $$get^conduitArticles(articleId,id,.article)
 m results("article")=article
 QUIT $$response^%zmgwebUtils(.results)
 ;
deleteArticle(req) ;
 ;
 n articleId,errors,id,json,results,slug
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s slug=$g(req("params","slug"))
 i slug="" d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," slug not defined",.errors)
 ;
 s articleId=$$getIdBySlug^conduitArticles(slug)
 i articleId="" QUIT $$notFound^%zmgweb()
 ;
 i $$getAuthor^conduitArticles(articleId)'=id d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," not owned by author",.errors)
 ;
 i $$del^conduitArticles(articleId)
 ;
 s json="{}"
 QUIT $$header^%zmgweb()_json
 ;
updateUser(req) ;
 ;
 n email,errors,id,image,password,payload,requiredFields,results
 n user,username
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s requiredFields("username")=""
 s requiredFields("email")=""
 i $$bodyAndFields(.req,"user",.requiredFields,"",.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s username=req("body","user","username")
 i username'?1A.AN!($l(username)>50) d
 . i $$addError("username","is invalid",.errors)
 i $$usernameExists^conduitUsers(username) d
 . i $$idByUsername^conduitUsers(username)'=id d
 . . i $$addError("username","has already been taken",.errors)
 ;
 s email=req("body","user","email")
 i $l(email)>255 d
 . i $$addError("email","is invalid",.errors)
 e  d
 . i '$$isValidEmail^%zmgwebUtils(email) d
 . . i $$addError("email","is invalid",.errors)
 . e  d
 . . i $$emailExists^conduitUsers(email) d
 . . . i $$idByEmail^conduitUsers(email)'=id d
 . . . . i $$addError("email","has already been taken",.errors)
 ;
 s password=$g(req("body","user","password"))
 i password'="",$l(password)<6 d
 . i $$addError("password","must be 6 or more characters in length",.errors)
 ;
 s image=$g(req("body","user","image"))
 i image'="" d
 . i $e(image,1,7)'="http://",$e(image,1,8)'="https://" d  q
 . . i $$addError("picture_url"," is an invalid URL",.errors)
 . n imgc
 . s imgc=$e(image,8,$l(image))
 . i imgc["http://"!(imgc["https://") d  q
 . . i $$addError("picture_url"," is an invalid URL",.errors)
 . i image[";"!(image["?") d  q
 . . i $$addError("picture_url"," is an invalid URL",.errors)
 . n c3,c4,revImg
 . s revImg=$reverse(image)
 . s c3=$reverse($e(revImg,1,3))
 . s c4=$reverse($e(revImg,1,4))
 . i c4'="jpeg",c3'="jpg",c3'="gif",c3'="png" d
 . . i $$addError("picture_url"," is an invalid image URL",.errors)
 ;
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 ; Update the persistent User record
 ;
 m user=req("body","user")
 i $$update^conduitUsers(id,.user)
 ;
 ; now retrieve the user object with JWT
 ;
 i $$getUserData(id,.results)
 QUIT $$response^%zmgwebUtils(.results)
 ;
follow(req) ;
 ;
 n errors,id,profile,results,usernameToFollow
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s usernameToFollow=$g(req("params","username"))
 i usernameToFollow="" d  QUIT $$errorResponse(.errors)
 . i $$addError("username"," to follow must be specified",.errors)
 ;
 i $$getUsername^conduitUsers(id)=usernameToFollow d  QUIT $$errorResponse(.errors)
 . i $$addError("username"," cannot be yourself",.errors)
 ;
 i '$$usernameExists^conduitUsers(usernameToFollow) QUIT $$notFound^%zmgweb()
 ;
 i $$follows^conduitUsers(id,usernameToFollow) d  QUIT $$errorResponse(.errors)
 . i $$addError("username"," is already being followed",.errors)
 ;
 i $$follow^conduitUsers(id,usernameToFollow,.profile)
 m results("profile")=profile
 QUIT $$response^%zmgwebUtils(.results)
 ;
unfollow(req) ;
 ;
 n errors,id,profile,results,usernameToUnfollow
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s usernameToUnfollow=$g(req("params","username"))
 i usernameToUnfollow="" d  QUIT $$errorResponse(.errors)
 . i $$addError("username"," to unfollow must be specified",.errors)
 ;
 i $$getUsername^conduitUsers(id)=usernameToUnfollow d  QUIT $$errorResponse(.errors)
 . i $$addError("username"," cannot be yourself",.errors)
 ;
 i '$$usernameExists^conduitUsers(usernameToUnfollow) QUIT $$notFound^%zmgweb()
 ;
 i '$$follows^conduitUsers(id,usernameToUnfollow) d  QUIT $$errorResponse(.errors)
 . i $$addError("username"," is not being followed",.errors)
 ;
 i $$unfollow^conduitUsers(id,usernameToUnfollow,.profile)
 m results("profile")=profile
 QUIT $$response^%zmgwebUtils(.results)
 ;
favorite(req) ;
 ;
 n article,articleId,errors,id,results,slug
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s slug=$g(req("params","slug"))
 i slug="" d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," slug not defined",.errors)
 ;
 s articleId=$$getIdBySlug^conduitArticles(slug)
 i articleId="" QUIT $$notFound^%zmgweb()
 ;
 i $$getAuthor^conduitArticles(articleId)'=id d
 . i $$favorited^conduitUsers(id,articleId)="false" d
 . . i $$favorite^conduitUsers(id,articleId)
 ;
 i $$get^conduitArticles(articleId,id,.article)
 m results("article")=article
 QUIT $$response^%zmgwebUtils(.results)
 ;
unfavorite(req) ;
 ;
 n article,articleId,errors,id,results,slug
 ;
 s id=$$mustAuthenticate(.req,.errors)
 i $d(errors) QUIT $$errorResponse(.errors)
 ;
 s slug=$g(req("params","slug"))
 i slug="" d  QUIT $$errorResponse(.errors)
 . i $$addError("article"," slug not defined",.errors)
 ;
 s articleId=$$getIdBySlug^conduitArticles(slug)
 i articleId="" QUIT $$notFound^%zmgweb()
 ;
 i $$getAuthor^conduitArticles(articleId)'=id d
 . i $$favorited^conduitUsers(id,articleId)="true" d
 . . i $$unfavorite^conduitUsers(id,articleId)
 ;
 i $$get^conduitArticles(articleId,id,.article)
 m results("article")=article
 QUIT $$response^%zmgwebUtils(.results)
 ;
conduitArticles^MAC^^65699,47011.75298^0
conduitArticles ;
 ;
 ;----------------------------------------------------------------------------
 ;| mgweb-conduit: mg-web Implementation of the Conduit Back-end             |
 ;|                                                                          |
 ;| Copyright (c) 2020 M/Gateway Developments Ltd,                           |
 ;| Redhill, Surrey UK.                                                      |
 ;| All rights reserved.                                                     |
 ;|                                                                          |
 ;| http://www.mgateway.com                                                  |
 ;| Email: rtweed@mgateway.com                                               |
 ;|                                                                          |
 ;|                                                                          |
 ;| Licensed under the Apache License, Version 2.0 (the "License");          |
 ;| you may not use this file except in compliance with the License.         |
 ;| You may obtain a copy of the License at                                  |
 ;|                                                                          |
 ;|     http://www.apache.org/licenses/LICENSE-2.0                           |
 ;|                                                                          |
 ;| Unless required by applicable law or agreed to in writing, software      |
 ;| distributed under the License is distributed on an "AS IS" BASIS,        |
 ;| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
 ;| See the License for the specific language governing permissions and      |
 ;|  limitations under the License.                                          |
 ;----------------------------------------------------------------------------
 ;
 ; 13 November 2020
 ;
slugify(value) ;
 ;
 n slug
 ;
 ; convert value to lower case
 s slug=$zconvert(value,"L")
 ;
 ; remove leading and trailing white-space
 if $zv["GT.M" do
 . s slug=$$FUNC^%TRIM(slug)
 else  do
 . s slug=$zstrip(slug,"<>W")
 ;
 ; convert remaining spaces and tabs to hyphens
 s slug=$tr(slug,$c(9,32,160),"---")
 ; replace diacritics, and some punctuation
 s slug=$tr(slug,"ãàáäâ?èéëêìíïîõòóöôùúüûñç·/_,:;","aaaaaeeeeeiiiiooooouuuunc------")
 ;
 if $zv["GT.M" do
 . n go,i,str
 . ; replace ampersand with -and-
 . s slug=$$^%MPIECE(slug,"&","-and-")
 . ; remove any other punctuation apart from hyphens
 . s str=""
 . f i=1:1:$l(slug) d
 . . n char
 . . s char=$e(slug,i)
 . . i char?1P,char'="-" q
 . . s str=str_char
 . s slug=str
 . ; remove anything that isn't a-z, 0-9 or a hyphen
 . s str=""
 . f i=1:1:$l(slug) d
 . . n char
 . . s char=$e(slug,i)
 . . i char?1L s str=str_char q
 . . i char?1N s str=str_char q
 . . i char="-" s str=str_char q 
 . s slug=str
 . ; remove any remaining leading, trailing or duplicate punctuation
 . s str=""
 . s go=0
 . f i=1:1:$l(slug) d
 . . n char
 . . s char=$e(slug,i)
 . . i go s str=str_char q
 . . i char'?1P d
 . . . s go=1
 . . . s str=str_char
 . s slug=str
 . s slug=$reverse(slug)
 . s str=""
 . s go=0
 . f i=1:1:$l(slug) d
 . . n char
 . . s char=$e(slug,i)
 . . i go s str=str_char q
 . . i char'?1P d
 . . . s go=1
 . . . s str=str_char
 . s slug=$reverse(str)
 . s slug=$$^%MPIECE(slug,"--","-")
 . ;
 else  do
 . ; replace ampersand with -and-
 . s slug=$replace(slug,"&","-and-")
 . ; remove any other punctuation apart from hyphens
 . s slug=$zstrip(slug,"*P",,"-")
 . ; remove anything that isn't a-z, 0-9 or a hyphen
 . s slug=##class(%Regex.Matcher).%New("[^a-z0-9-]+", slug).ReplaceAll("")
 . ; remove any remaining leading, trailing or duplicate punctuation
 . s slug=$zstrip(slug, "<>=P")
 ;
 QUIT slug
 ;
getNextId() ;
 QUIT $increment(^conduitArticles("nextId"))
 ;
articleExists(articleId) ;
 QUIT $d(^conduitArticles("byId",articleId))
 ;
getAuthor(articleId) ;
 QUIT ^conduitArticles("byId",articleId,"author")
 ;
slugExists(slug) ;
 QUIT $d(^conduitArticles("bySlug",slug))
 ;
createSlug(title,articleId) ;
 s slug=$$slugify(title)
 if ($$slugExists(slug)) d
 . s slug=slug_"-x"_articleId
 QUIT slug
 ;
getTimeStamp(results) ;
 ;
 n iso,now,ts
 ;
 k results
 s now=$h
 i $zv'["GT.M" s now=$zts
 s iso=$$UTCDateTime^%zmgwebUtils(now)
 ; get reverse chronological index timestamp value
 s ts=100000000000000-$$epochTime^%zmgwebUtils(now)
 s results("iso")=iso
 s results("ts")=ts
 QUIT 1
 ;
 ;
 ; ==========================
 ;
create(authorId,data) ;
 ;
 n article,articleId,iso,n,slug,tag,timestamp,ts
 ;
 s articleId=$$getNextId()
 ;
 ; derive a unique slug based on title
 ;
 s slug=$$createSlug(data("title"),articleId)
 i $$getTimeStamp(.timestamp)
 s ts=timestamp("ts")
 s iso=timestamp("iso")
 ;
 m article=data
 s article("createdAt")=iso
 s article("updatedAt")=iso
 s article("timestampindex")=ts
 s article("favoritesCount")=0
 s article("author")=authorId
 s article("slug")=slug
 ;
 ; save to database
 ;
 m ^conduitArticles("byId",articleId)=article
 ;
 ; create indices
 ;
 s ^conduitArticles("bySlug",slug)=articleId
 s ^conduitArticles("byAuthor",authorId,articleId)=articleId
 s ^conduitArticles("byTimestamp",ts)=articleId
 ;
 s n=""
 f  s n=$o(data("tagList",n)) q:n=""  d
 . s tag=data("tagList",n)
 . s ^conduitArticles("byTag",tag,articleId)=articleId
 ;
 QUIT articleId
 ;
del(articleId) ;
 ;
 n authorId,slug,n,tag,ts
 ;
 i '$$articleExists(articleId) QUIT
 ;
 s slug=$g(^conduitArticles("byId",articleId,"slug"))
 k ^conduitArticles("bySlug",slug) 
 ; delete author index
 s authorId=$$getAuthor(articleId)
 k ^conduitArticles("byAuthor",authorId,articleId) 
 ; delete timestamp index
 s ts=$g(^conduitArticles("byId",articleId,"timestampindex"))
 k ^conduitArticles("byTimestamp",ts) 
 ; delete tagList indices
 s n=""
 f  s n=$o(^conduitArticles("byId",articleId,"tagList",n)) q:n=""  d
 . s tag=^conduitArticles("byId",articleId,"tagList",n)
 . k ^conduitArticles("byTag",tag,articleId)
 ; delete any associated comment records
 s commentId=""
 f  s commentid=$o(^conduitArticles("byId",articleId,"comments",commentId)) q:commentId=""  d
 . i $$del^conduitComments(commentid,0)
 ; finally, delete article record
 k ^conduitArticles("byId",articleId)
 QUIT 1
 ;
getTags(tags) ;
 ;
 n count,max,no,stop,tag,tagsByCount
 ;
 s max=100
 k tags
 ; count how many instances for each tag
 ; and store temporarily by frequency 
 s tag=""
 f  s tag=$o(^conduitArticles("byTag",tag)) q:tag=""  d
 . n id
 . s count=0
 . s id=""
 . f  s id=$o(^conduitArticles("byTag",tag,id)) q:id=""  d
 . . s count=count+1
 . ;
 . s tagsByCount(count,tag)=""
 ;
 ; now go through temp array in reverse to get the
 ; most frequent tags first.  Only return up
 ; to the max required no of tags
 s stop=0
 s no=0
 s count=""
 f  s count=$o(tagsByCount(count),-1) q:stop  q:count=""  d
 . s tag=""
 . f  s tag=$o(tagsByCount(count,tag)) q:stop  q:tag=""  d
 . . s no=no+1
 . . i no'>max d
 . . . n i
 . . . s i=$increment(tags)
 . . . s tags(i)=tag
 . . e  d
 . . . s stop=1
 ;
 QUIT 1
 ;
getIdBySlug(slug) ;
 ;
 QUIT $g(^conduitArticles("bySlug",slug))
 ;
getFeed(userId,offset,max,articles) ;
 ;
 n allFound,count,followsId,skipped,total,ts
 ;
 k ^conduitTemp($j)
 ;
 s total=0
 s allFound=0
 s skipped=0
 s count=0
 s followsId=""
 f  s followsId=$o(^conduitUsers("byId",userId,"follows",followsId)) q:followsId=""  d
 . n articleId
 . s articleId=""
 . f  s articleId=$o(^conduitArticles("byAuthor",followsId,articleId)) q:articleId=""  d
 . . s total=total+1
 . . i 'allFound d
 . . . i offset>0,skipped<offset d
 . . . . s skipped=skipped+1
 . . . e  d
 . . . . s ts=^conduitArticles("byId",articleId,"timestampindex")
 . . . . s ^conduitTemp($j,ts)=articleId
 . . . . s count=count+1
 . . . . i count=max d
 . . . . . s allFound=1
 ;
 ; now spin through the temporary document to pull out articles latest first
 ;
 k articles
 ;
 s ts=""
 f  s ts=$o(^conduitTemp($j,ts)) q:ts=""  d
 . n article,articleId,id
 . s id=$increment(articles)
 . s articleId=^conduitTemp($j,ts)
 . i $$get(articleId,userId,.article)
 . m articles(id)=article
 ;
 k ^conduitTemp($j)
 ;
 QUIT total
 ;
get(articleId,byUserId,article) ;
 ;
 n author,profile
 ;
 k article
 m article=^conduitArticles("byId",articleId)
 k article("timestampindex")
 k article("comments")
 s article("favorited")=$$favorited^conduitUsers(byUserId,articleId)
 s author=article("author")
 k article("author")
 i $$getProfile^conduitUsers(author,byUserId,.profile)
 m article("author")=profile
 ;
 QUIT 1
 ;
byAuthor(username,byUserId,offset,max,results) ;
 ;
 n allFound,articleId,articles,count,skipped,total,ts,userId
 ;
 k results
 ;
 s userId=$$idByUsername^conduitUsers(username)
 i userId="" d  QUIT -1
 . s articles("error")="notFound"
 ;
 k ^conduitTemp($j)
 ;
 s total=0
 s allFound=0
 s skipped=0
 s count=0
 s articleId=""
 f  s articleId=$o(^conduitArticles("byAuthor",userId,articleId)) q:articleId=""  d
 . s total=total+1
 . i 'allFound d
 . . i offset>0,skipped<offset d
 . . . s skipped=skipped+1
 . . e  d
 . . . s ts=^conduitArticles("byId",articleId,"timestampindex")
 . . . s ^conduitTemp($j,ts)=articleId
 . . . s count=count+1
 . . . i count=max s allFound=1
 ;
 ; now spin through the temporary document to pull out articles latest first
 ;
 k articles
 ;
 s ts=""
 f  s ts=$o(^conduitTemp($j,ts)) q:ts=""  d
 . s ^articles("o",ts)=""
 . n article,articleId,id
 . s id=$increment(articles)
 . s articleId=^conduitTemp($j,ts)
 . i $$get(articleId,byUserId,.article)
 . m articles(id)=article
 ;
 k ^conduitTemp($j)
 m results("articles")=articles
 s results("articlesCount")=total
 ;
 QUIT total
 ;
byTag(tag,byUserId,offset,max,results) ;
 ;
 n allFound,articleId,articles,count,skipped,total,ts
 ;
 k results
 k ^conduitTemp($j)
 ;
 s total=0
 s allFound=0
 s skipped=0
 s count=0
 s articleId=""
 f  s articleId=$o(^conduitArticles("byTag",tag,articleId)) q:articleId=""  d
 . s total=total+1
 . i 'allFound d
 . . i offset>0,skipped<offset d
 . . . s skipped=skipped+1
 . . e  d
 . . . s ts=^conduitArticles("byId",articleId,"timestampindex")
 . . . s ^conduitTemp($j,ts)=articleId
 . . . s count=count+1
 . . . i count=max s allFound=1
 ;
 ; now spin through the temporary document to pull out articles latest first
 ;
 k articles
 ;
 s ts=""
 f  s ts=$o(^conduitTemp($j,ts)) q:ts=""  d
 . n article,articleId,id
 . s id=$increment(articles)
 . s articleId=^conduitTemp($j,ts)
 . i $$get(articleId,byUserId,.article)
 . m articles(id)=article
 ;
 k ^conduitTemp($j)
 m results("articles")=articles
 s results("articlesCount")=total
 ;
 QUIT total
 ;
favoritedBy(username,byUserId,offset,max,results) ;
 ;
 n allFound,articleId,articles,count,skipped,total,ts,userId
 ;
 k results
 k ^conduitTemp($j)
 ;
 s userId=$$idByUsername^conduitUsers(username)
 i userId="" d  QUIT -1
 . s articles("error")="notFound"
 ;
 s total=0
 s allFound=0
 s skipped=0
 s count=0
 s articleId=""
 f  s articleId=$o(^conduitUsers("byId",userId,"favorited",articleId)) q:articleId=""  d
 . i $d(^conduitArticles("byId",articleId)) d
 . . s total=total+1
 . . i 'allFound d
 . . . i offset>0,skipped<offset d
 . . . . s skipped=skipped+1
 . . . e  d
 . . . . s ts=^conduitArticles("byId",articleId,"timestampindex")
 . . . . s ^conduitTemp($j,ts)=articleId
 . . . . s count=count+1
 . . . . i count=max s allFound=1
 ;
 ; now spin through the temporary document to pull out articles latest first
 ;
 k articles
 ;
 s ts=""
 f  s ts=$o(^conduitTemp($j,ts)) q:ts=""  d
 . n article,articleId,id
 . s id=$increment(articles)
 . s articleId=^conduitTemp($j,ts)
 . i $$get(articleId,byUserId,.article)
 . m articles(id)=article
 ;
 k ^conduitTemp($j)
 m results("articles")=articles
 s results("articlesCount")=total
 ;
 QUIT total
 ;
latest(byUserId,offset,max,results) ;
 ;
 n allFound,articles,count,skipped,total,ts
 ;
 s skipped=0
 s count=0
 s total=0
 s allFound=0
 ;
 k results
 ;
 s ts=""
 f  s ts=$o(^conduitArticles("byTimestamp",ts)) q:ts=""  d
 . s total=total+1
 . i 'allFound d
 . . i offset>0,skipped<offset d
 . . . s skipped=skipped+1
 . . e  d
 . . . n article,articleId
 . . . s articleId=$g(^conduitArticles("byTimestamp",ts))
 . . . i $$get(articleId,byUserId,.article)
 . . . s id=$increment(articles)
 . . . m articles(id)=article
 . . . s count=count+1
 . . . i count=max s allFound=1
 ;
 m results("articles")=articles
 s results("articlesCount")=total
 QUIT total
 ;
update(articleId,userId,newData) ;
 ;
 n article,currentSlug,currentTitle,n,newTitle,tag,timestamp,ts
 ;
 m article=^conduitArticles("byId",articleId)
 ;
 s currentTitle=$g(article("title"))
 s currentSlug=$g(article("slug"))
 s newTitle=$g(newData("title"))
 ;
 i newTitle'="",newTitle'=currentTitle d
 . ; remove the old slug index
 . k ^conduitArticles("bySlug",currentSlug)
 . ; create and index the new slug
 . s newSlug=$$createSlug(newTitle,articleId)
 . s ^conduitArticles("bySlug",newSlug)=articleId
 . s article("slug")=newSlug
 . s article("title")=newTitle
 ;
 i $d(newData("description")) d
 . s article("description")=newData("description")
 i $d(newData("body")) d
 . s article("body")=newData("body")
 s article("updatedAt")=$$UTCDateTime^%zmgwebUtils($h)
 s ts=article("timestampindex")
 k ^conduitArticles("byTimestamp",ts)
 i $$getTimeStamp(.timestamp)
 s ts=timestamp("ts")
 s ^conduitArticles("byTimestamp",ts)=articleId
 s article("timestampindex")=ts
 ;
 ; update tags
 ;
 ; first remove all the tags from the data record
 ; and remove from the corresponding index
 ;
 s n=""
 f  s n=$o(^conduitArticles("byId",articleId,"tagList",n)) q:n=""  d
 . s tag=^conduitArticles("byId",articleId,"tagList",n)
 . k ^conduitArticles("byTag",tag,articleId)
 k ^conduitArticles("byId",articleId,"tagList")
 ; 
 ; now update tags in article and create new taglist index
 ;
 k article("tagList")
 m article("tagList")=newData("tagList")
 s n=""
 f  s n=$o(newData("tagList",n)) q:n=""  d
 . s tag=newData("tagList",n)
 . s ^conduitArticles("byTag",tag,articleId)=articleId
 ;
 ; update main article database record
 ;
 m ^conduitArticles("byId",articleId)=article
 ;
 QUIT 1
 ;
rebuildIndices() ;
 ;
 n count,id
 ;
 k ^conduitArticles("byAuthor")
 k ^conduitArticles("bySlug")
 k ^conduitArticles("byTag")
 k ^conduitArticles("byTimestamp")
 ;
 s count=0
 s id=""
 f  s id=$o(^conduitArticles("byId",id)) q:id=""  d
 . n article,n,tag
 . s count=count+1
 . m article=^conduitArticles("byId",id)
 . s ^conduitArticles("byAuthor",article("author"),id)=id
 . s ^conduitArticles("bySlug",article("slug"))=id
 . s ^conduitArticles("byTimestamp",article("timestampindex"))=id
 . s n=""
 . s n=$o(article("tagList",n)) q:n=""  d
 . . s tag=article("tagList",n)
 . . s ^conduitArticles("byTag",tag,id)=id
 ;
 QUIT count
 ;
.

conduitComments^MAC^^65699,47073.264204^0
conduitComments ; Conduit Comments Database functions
 ;
 ;----------------------------------------------------------------------------
 ;| mgweb-conduit: mg-web Implementation of the Conduit Back-end             |
 ;|                                                                          |
 ;| Copyright (c) 2020 M/Gateway Developments Ltd,                           |
 ;| Redhill, Surrey UK.                                                      |
 ;| All rights reserved.                                                     |
 ;|                                                                          |
 ;| http://www.mgateway.com                                                  |
 ;| Email: rtweed@mgateway.com                                               |
 ;|                                                                          |
 ;|                                                                          |
 ;| Licensed under the Apache License, Version 2.0 (the "License");          |
 ;| you may not use this file except in compliance with the License.         |
 ;| You may obtain a copy of the License at                                  |
 ;|                                                                          |
 ;|     http://www.apache.org/licenses/LICENSE-2.0                           |
 ;|                                                                          |
 ;| Unless required by applicable law or agreed to in writing, software      |
 ;| distributed under the License is distributed on an "AS IS" BASIS,        |
 ;| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
 ;| See the License for the specific language governing permissions and      |
 ;|  limitations under the License.                                          |
 ;----------------------------------------------------------------------------
 ;
 ; 13 November 2020
 ;
 ;
 ; ================
 ;
getNextId() 
 QUIT $increment(^conduitComments("nextid"))
 ;
exists(commentId) ;
 QUIT $d(^conduitComments("byId",commentId))
 ;
getAuthor(commentId) ;
 QUIT $g(^conduitComments("byId",commentId,"author"))
 ;
linkComment(articleId,commentId) ;
 s ^conduitArticles("byId",articleId,"comments",commentId)=commentId
 QUIT 1
 ;
unlinkComment(articleId,commentId) ;
 k ^conduitArticles("byId",articleId,"comments",commentId)
 QUIT 1
 ;
create(authorId,articleId,commentBody) ;
 ;
 n comment,commentid,iso
 ;
 s commentId=$$getNextId()
 s iso=$$UTCDateTime^%zmgwebUtils($$now^%zmgwebUtils())
 s comment("id")=commentId
 s comment("articleId")=articleId
 s comment("body")=commentBody
 s comment("author")=authorId
 s comment("createdAt")=iso
 s comment("updatedAt")=iso
 ;
 m ^conduitComments("byId",commentId)=comment
 i $$linkComment(articleId,commentId)
 ;
 QUIT commentId
 ;
del(commentId,unlinkArticle) ;
 ;
 n articleId,ok
 ;
 i '$d(unlinkArticle) s unlinkArticle=1
 s articleId=$g(^conduitComments("byId",commentId,"articleId"))
 k ^conduitComments("byId",commentId)
 i unlinkArticle s ok=$$unlinkComment(articleId,commentId)
 ;
 QUIT 1
 ;
get(commentId,byUserId,comment) ;
 ;
 n ofUserId,profile
 ;
 k comment
 m comment=^conduitComments("byId",commentId)
 k comment("articleId")
 s ofUserId=comment("author")
 k comment("author")
 i $$getProfile^conduitUsers(ofUserId,byUserId,.profile)
 m comment("author")=profile
 ;
 QUIT 1
 ;
byUser(userId,articleId,comments) ;
 ;
 n commentId
 ;
 k comments
 ;
 ; get comment records for the article
 ;
 s commentId=""
 f  s commentId=$o(^conduitArticles("byId",articleId,"comments",commentId)) q:commentId=""  d
 . n comment,id
 . i $$get(commentId,userId,.comment)
 . s id=$increment(comments)
 . m comments(id)=comment
 ;
 QUIT 1
 ;
.

conduitUsers^MAC^^65699,47160.363421^0
conduitUsers ; Conduit Users Database functions
 ;
 ;----------------------------------------------------------------------------
 ;| mgweb-conduit: mg-web Implementation of the Conduit Back-end             |
 ;|                                                                          |
 ;| Copyright (c) 2020 M/Gateway Developments Ltd,                           |
 ;| Redhill, Surrey UK.                                                      |
 ;| All rights reserved.                                                     |
 ;|                                                                          |
 ;| http://www.mgateway.com                                                  |
 ;| Email: rtweed@mgateway.com                                               |
 ;|                                                                          |
 ;|                                                                          |
 ;| Licensed under the Apache License, Version 2.0 (the "License");          |
 ;| you may not use this file except in compliance with the License.         |
 ;| You may obtain a copy of the License at                                  |
 ;|                                                                          |
 ;|     http://www.apache.org/licenses/LICENSE-2.0                           |
 ;|                                                                          |
 ;| Unless required by applicable law or agreed to in writing, software      |
 ;| distributed under the License is distributed on an "AS IS" BASIS,        |
 ;| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
 ;| See the License for the specific language governing permissions and      |
 ;|  limitations under the License.                                          |
 ;----------------------------------------------------------------------------
 ;
 ; 13 November 2020
 ;
getTimeStamp(results) ;
 ;
 n iso,now,ts
 ;
 k results
 s now=$$now^%zmgwebUtils()
 s iso=$$UTCDateTime^%zmgwebUtils(now)
 ; get reverse chronological index timestamp value
 s ts=100000000000000-$$epochTime^%zmgwebUtils(now)
 s results("iso")=iso
 s results("ts")=ts
 QUIT 1
 ;
hashPassword(password) ;
 ;
 n hash
 ;
 i $zv["GT.M" d
 . s hash=$$bcryptHash^%zmgwebUtils(password)
 e  d
 . n salt
 . s salt=##class(%SYSTEM.Encryption).GenCryptRand(32)
 . s hash=##class(%SYSTEM.Encryption).PBKDF2(password,20,salt,32,512)
 . s hash=##class(%SYSTEM.Encryption).Base64Encode(salt)_"$32$"_##class(%SYSTEM.Encryption).Base64Encode(hash)
 ;
 QUIT hash
 ;
verifyPassword(password,hash) ;
 ;
 n ok
 ;
 i $zv["GT.M" d
 . s ok=$$bcryptCompare^%zmgwebUtils(password,hash)
 e  d
 . n hash2,salt
 . s salt=$p(hash,"$32$",1)
 . s hash=$p(hash,"$32$",2) 
 . s salt=##class(%SYSTEM.Encryption).Base64Decode(salt)
 . s hash2=##class(%SYSTEM.Encryption).PBKDF2(password,20,salt,32,512)
 . s hash2=##class(%SYSTEM.Encryption).Base64Encode(hash2)
 . s ok=(hash=hash2)
 ;
 QUIT ok
 ;
 ; ==========================
 ;
exists(id) ;
 QUIT $d(^conduitUsers("byId",id))
 ;
emailExists(email) ;
 QUIT $d(^conduitUsers("byEmail",email))
 ;
getEmail(id) ;
 QUIT $g(^conduitUsers("byId",id,"email"))
 ;
changeEmail(id,newEmail) ;
 ;
 n oldEmail
 ;
 s oldEmail=$$getEmail(id)
 k ^conduitUsers("byEmail",oldEmail)
 s ^conduitUsers("byEmail",newEmail)=id
 s ^conduitUsers("byId",id,"email")=newEmail
 QUIT 1
 ;
usernameExists(username) ;
 QUIT $d(^conduitUsers("byUsername",username))
 ;
idByUsername(username) ;
 QUIT $g(^conduitUsers("byUsername",username))
 ;
changeUsername(id,newUsername) ;
 ;
 k ^conduitUsers("byUsername",$$getUsername(id))
 s ^conduitUsers("byUsername",newUsername)=id
 s ^conduitUsers("byId",id,"username")=newUsername
 ;
 QUIT 1
 ;
getUsername(id) ;
 QUIT $g(^conduitUsers("byId",id,"username"))
 ;
idByEmail(email) ;
 QUIT $g(^conduitUsers("byEmail",email))
 ;
authenticate(email,password) ;
 n ok
 i $$emailExists(email) d  QUIT ok
 . n hash,id
 . s id=$$idByEmail(email)
 . s hash=$g(^conduitUsers("byId",id,"password"))
 . s ok=$$verifyPassword(password,hash)
 QUIT 0
 ;
get(id,user) ;
 ;
 k user
 ;
 m user=^conduitUsers("byId",id)
 QUIT $d(user)
 ;
getNextId() ;
 QUIT $increment(^conduitUsers("nextId"))
 ;
create(user) ;
 ;
 ;    user: {
 ;      username,
 ;      email,
 ;      password
 ;    }
 ;
 n hash,id,now,password
 ;
 s id=$$getNextId()
 s user("id")=id
 s now=$$UTCDateTime^%zmgwebUtils($$now^%zmgwebUtils()) 
 s user("createdAt")=now
 s user("updatedAt")=now
 s password=$g(user("password"))
 s hash=$$hashPassword(password)
 s user("password")=hash
 s user("bio")=""
 s user("image")=""
 ;
 m ^conduitUsers("byId",id)=user
 s ^conduitUsers("byUsername",user("username"))=id
 s ^conduitUsers("byEmail",user("email"))=id
 ;
 QUIT id
 ;
update(id,newData) ;
 ;
 n ok
 ;
 i '$$exists(id) QUIT 0
 ;
 i $d(newData("email")) s ok=$$changeEmail(id,newData("email"))
 i $d(newData("username")) s ok=$$changeUsername(id,newData("username"))
 i $g(newData("password"))'="" d
 . s ^conduitUsers("byId",id,"password")=$$hashPassword(newData("password"))
 i $d(newData("image")) s ^conduitUsers("byId",id,"image")=newData("image")
 i $d(newData("bio")) s ^conduitUsers("byId",id,"bio")=newData("bio")
 s ^conduitUsers("byId",id,"updatedAt")=$$UTCDateTime^%zmgwebUtils($$now^%zmgwebUtils()) 
 ;
 QUIT 1
 ;
favorited(userId,articleId) ;
 ;
 n favorited
 ;
 s favorited="false"
 ;
 i userId=""!(articleId="") QUIT favorited
 i $d(^conduitUsers("byId",userId,"favorited",articleId)) s favorited="true"
 QUIT favorited
 ;
favorite(userId,articleId) ;
 s ^conduitUsers("byId",userId,"favorited",articleId)=articleId
 i $increment(^conduitArticles("byId",articleId,"favoritesCount"))
 QUIT 1
 ;
unfavorite(userId,articleId) ;
 ;
 n count
 ;
 k ^conduitUsers("byId",userId,"favorited",articleId)
 s count=+$g(^conduitArticles("byId",articleId,"favoritesCount"))
 s count=count-1
 i count<0 s count=0
 s ^conduitArticles("byId",articleId,"favoritesCount")=count
 QUIT 1
 ;
getProfile(ofUserId,byUserId,profile) ;
 ;
 n x
 ;
 k profile
 ;
 i '$d(^conduitUsers("byId",ofUserId)) d  QUIT 0
 . s profile("error")="User whose profile is being requested does not exist"
 ;
 i $g(byUserId)'="",'$d(^conduitUsers("byId",byUserId)) d  QUIT 0
 . s profile("error")="User requesting profile does not exist"
 ;
 s profile("username")=$g(^conduitUsers("byId",ofUserId,"username"))
 s profile("bio")=$g(^conduitUsers("byId",ofUserId,"bio"))
 s profile("image")=$g(^conduitUsers("byId",ofUserId,"image"))
 s profile("following")="false"
 i $g(byUserId)'="",$d(^conduitUsers("byId",byUserId,"follows",ofUserId)) d
 . s profile("following")="true"
 QUIT 1
 ;
follows(userId,usernameToFollow) ;
 ;
 n idToFollow
 ;
 s idToFollow=$$idByUsername(usernameToFollow)
 QUIT $d(^conduitUsers("byId",userId,"follows",idToFollow))
 ;
follow(userId,usernameToFollow,profile) ;
 ;
 n idToFollow
 ;
 s idToFollow=$$idByUsername(usernameToFollow)
 s ^conduitUsers("byId",userId,"follows",idToFollow)=idToFollow
 i $$getProfile(idToFollow,userId,.profile)
 QUIT 1
 ;
unfollow(userId,usernameToUnfollow,profile) ;
 ;
 n idToUnfollow
 ;
 s idToUnfollow=$$idByUsername(usernameToUnfollow)
 k ^conduitUsers("byId",userId,"follows",idToUnfollow)
 i $$getProfile(idToUnfollow,userId,.profile)
 QUIT 1
 ;
.
.



